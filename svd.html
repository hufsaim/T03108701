<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVD Analysis</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>

    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #f4f6f8; margin: 0; padding: 20px; color: #333; position: relative; }
        
        /* Home Button */
        .home-btn {
            position: absolute; top: 20px; left: 20px;
            background-color: #34495e; color: white;
            text-decoration: none; padding: 10px 15px;
            border-radius: 5px; font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: 0.3s; display: flex; align-items: center; gap: 5px; z-index: 100;
        }
        .home-btn:hover { background-color: #2c3e50; transform: translateY(-2px); }

        .container { max-width: 1000px; margin: 0 auto; background: #fff; padding: 30px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); }
        h1, h2 { text-align: center; color: #2c3e50; margin-bottom: 10px; }
        h2 { margin-top: 40px; border-bottom: 2px solid #eee; padding-bottom: 10px; font-size: 1.4rem; }
        
        .controls { text-align: center; margin: 20px 0; padding: 20px; background: #eef2f7; border-radius: 8px; border: 1px dashed #cbd5e0; }
        #status { font-weight: bold; color: #e74c3c; min-height: 20px; margin-top: 10px; white-space: pre-wrap;}

        .comparison-area { display: flex; justify-content: space-around; flex-wrap: wrap; gap: 20px; margin-top: 20px; }
        .image-box { text-align: center; }
        .image-box canvas { border: 1px solid #ddd; box-shadow: 2px 4px 8px rgba(0,0,0,0.1); max-width: 100%; }
        .label { display: block; margin-top: 8px; font-weight: bold; color: #555; }
        
        .slider-container { text-align: center; margin: 20px 0; display: none; background: #fff; padding: 10px; }
        input[type=range] { width: 300px; accent-color: #3498db; }
        
        .rank-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin-top: 20px; }
        .rank-item { text-align: center; background: #fafafa; padding: 8px; border-radius: 5px; border: 1px solid #eee; transition: transform 0.2s; }
        .rank-item:hover { transform: scale(1.03); border-color: #3498db; }
        .rank-item canvas { width: 100%; height: auto; border: 1px solid #ddd; }
        .rank-info { font-size: 0.8rem; color: #666; margin-top: 5px; }

        #plot-area { width: 100%; height: 400px; margin-top: 20px; }

        /* HUFS BME Footer Style */
        .footer-signature {
            width: 100%;
            text-align: right;
            font-size: 12px;
            color: #888;
            border-top: 1px solid #eee;
            padding-top: 15px;
            margin-top: 20px;
            font-style: italic;
        }
        .footer-signature strong {
            color: #002c5f; /* HUFS Navy Blue ÎπÑÏä∑Ìïú ÏÉâÏÉÅ */
        }
    </style>
</head>
<body>

    <a href="https://hufsaim.github.io/T03108701/" class="home-btn">üè† Home</a>

    <div class="container">
        <h1>üñºÔ∏è Image SVD Visualizer</h1>
        <p style="text-align: center; color: #7f8c8d;">
            Ïù¥ÎØ∏ÏßÄÎ•º ÌùëÎ∞±ÏúºÎ°ú Î≥ÄÌôòÌïòÏó¨ matrix AÎ•º Ï†ïÏùòÌïòÍ≥†, SVDÎ•º ÏßÑÌñâÌï©ÎãàÎã§.<br>
        </p>

        <div class="controls">
            <input type="file" id="imageInput" accept="image/*">
            <div id="status"></div>
        </div>

        <h2>1. Ïù¥ÎØ∏ÏßÄ Ïû¨Íµ¨ÏÑ± (Reconstruction)</h2>
        <div class="slider-container" id="sliderArea">
            <label for="kSlider">Singular Value (ÌäπÏù¥Í∞í) Í∞úÏàò (k): <span id="kValue" style="color:#2980b9; font-weight:bold; font-size: 1.2rem;">10</span></label><br>
            <input type="range" id="kSlider" min="1" max="50" value="10">
        </div>

        <div class="comparison-area">
            <div class="image-box">
                <canvas id="originalCanvas"></canvas>
                <span class="label" id="origLabel">ÏõêÎ≥∏ (Grayscale)</span>
            </div>
            <div class="image-box">
                <canvas id="reconCanvas"></canvas>
                <span class="label" id="reconLabel">Ïû¨Íµ¨ÏÑ± ($k=10$)</span>
            </div>
        </div>

        <h2>2. Top 12 Rank-1 Matrices</h2>
        <div id="rankGrid" class="rank-grid"></div>

        <h2>3. Singular Value Î∂ÑÌè¨</h2>
        <div id="plot-area"></div>

        <div class="footer-signature">
            Software provided by <strong>HUFS BME Linear Algebra class</strong>
        </div>    

    </div>


<script>
    const imageInput = document.getElementById('imageInput');
    const statusDiv = document.getElementById('status');
    const originalCanvas = document.getElementById('originalCanvas');
    const reconCanvas = document.getElementById('reconCanvas');
    const rankGrid = document.getElementById('rankGrid');
    const kSlider = document.getElementById('kSlider');
    const kValue = document.getElementById('kValue');
    const sliderArea = document.getElementById('sliderArea');
    const reconLabel = document.getElementById('reconLabel');
    const origLabel = document.getElementById('origLabel');

    let svdResult = null; 
    let imgWidth = 0;
    let imgHeight = 0;

    imageInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        statusDiv.textContent = "‚è≥ Ïù¥ÎØ∏ÏßÄ Î°úÎî© Ï§ë...";
        svdResult = null;
        sliderArea.style.display = "none";
        rankGrid.innerHTML = "";
        Plotly.purge('plot-area');

        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => processImage(img);
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });

    function processImage(img) {
        statusDiv.textContent = "‚è≥ Ï†ÑÏ≤òÎ¶¨ Ï§ë... (Safe Resizing)";
        
        const MAX_DIMENSION = 256; 

        let width = img.width;
        let height = img.height;
        let scale = Math.min(1, MAX_DIMENSION / width, MAX_DIMENSION / height);
        
        width = Math.floor(width * scale);
        height = Math.floor(height * scale);
        
        if(width % 2 !== 0) width--;
        if(height % 2 !== 0) height--;

        imgWidth = width;
        imgHeight = height;
        
        origLabel.textContent = `ÏõêÎ≥∏ (Gray) - ${width}x${height}`;
        reconCanvas.width = width;
        reconCanvas.height = height;
        originalCanvas.width = width;
        originalCanvas.height = height;

        const ctx = originalCanvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        const imgData = ctx.getImageData(0, 0, width, height);
        const matrix = convertToGrayscaleMatrixWithNoise(imgData, width, height);
        
        drawMatrixToCanvas(matrix, originalCanvas); 

        statusDiv.innerHTML = `‚è≥ SVD Í≥ÑÏÇ∞ Ï§ë...<br>(ÌÅ¨Í∏∞: ${width}x${height}, Wide: ${width > height ? 'Yes' : 'No'})`;
        
        setTimeout(() => {
            requestAnimationFrame(() => performSVD(matrix));
        }, 100);
    }

    function convertToGrayscaleMatrixWithNoise(imgData, w, h) {
        let matrix = [];
        for (let y = 0; y < h; y++) {
            let row = [];
            for (let x = 0; x < w; x++) {
                const idx = (y * w + x) * 4;
                const gray = 0.299 * imgData.data[idx] + 0.587 * imgData.data[idx+1] + 0.114 * imgData.data[idx+2];
                // Noise Injection
                const epsilon = Math.random() * 0.0001; 
                row.push(gray + epsilon);
            }
            matrix.push(row);
        }
        return matrix;
    }

    // --- Helper to Transpose Matrix ---
    function transpose(matrix) {
        return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
    }

    // --- SVD Logic with Transpose Check ---
    function performSVD(matrix) {
        try {
            const startTime = performance.now();
            const rows = matrix.length;
            const cols = matrix[0].length;
            let processingMatrix = matrix;
            let isTransposed = false;

            // [FIX] Í∞ÄÎ°úÍ∞Ä Îçî Í∏∏Î©¥(Wide Matrix), Ï†ÑÏπò(Transpose)ÌïòÏó¨ ÏÑ∏Î°úÍ∞Ä Îçî Í∏∏Í≤å ÎßåÎì† ÌõÑ Í≥ÑÏÇ∞
            if (cols > rows) {
                processingMatrix = transpose(matrix);
                isTransposed = true;
                console.log("Wide matrix detected. Transposing for stability...");
            }
            
            // SVD ÏàòÌñâ
            const svd = numeric.svd(processingMatrix);
            
            // Í≤∞Í≥º Ï†ïÎ¶¨
            let U, S, V;

            if (isTransposed) {
                // Ï†ÑÏπòÌï¥ÏÑú Í≥ÑÏÇ∞ÌñàÏúºÎØÄÎ°ú UÏôÄ VÎ•º Î∞îÍøîÏÑú Ìï†Îãπ
                // ÏõêÎûò A = U S V^T
                // A^T = V S U^T (Ïó¨Í∏∞ÏÑú Í≥ÑÏÇ∞Îêú svd.UÍ∞Ä VÍ∞Ä ÎêòÍ≥†, svd.VÍ∞Ä UÍ∞Ä Îê®)
                U = svd.V;
                S = svd.S;
                V = svd.U;
            } else {
                U = svd.U;
                S = svd.S;
                V = svd.V;
            }

            const endTime = performance.now();
            const timeTaken = ((endTime - startTime) / 1000).toFixed(2);
            
            svdResult = { U: U, S: S, V: V };

            statusDiv.innerHTML = `‚úÖ ÏôÑÎ£å! (${timeTaken}s, œÉ Í∞úÏàò: ${S.length})`;
            statusDiv.style.color = "#27ae60";

            sliderArea.style.display = "block";
            kSlider.max = Math.min(50, S.length);
            kSlider.value = 10;
            kValue.textContent = 10;

            visualizeRankOneMatrices(12);
            reconstructImage(10);
            drawSingularValuePlot(S); 

        } catch (err) {
            console.error(err);
            statusDiv.innerHTML = `‚ùå Í≥ÑÏÇ∞ Ïã§Ìå®.<br>Ïò§Î•ò: ${err.message}`;
            statusDiv.style.color = "#c0392b";
        }
    }

    // --- Visualization & Helpers ---
    function visualizeRankOneMatrices(n) {
        rankGrid.innerHTML = "";
        for (let i = 0; i < n; i++) {
            const sigma = svdResult.S[i];
            const u = getColumn(svdResult.U, i);
            const v = getColumn(svdResult.V, i);
            const rank1Mat = outerProduct(u, v, sigma);
            
            const div = document.createElement('div');
            div.className = 'rank-item';
            const cvs = document.createElement('canvas');
            cvs.width = imgWidth; cvs.height = imgHeight;
            drawMatrixToCanvasNormalized(rank1Mat, cvs);
            
            const info = document.createElement('div');
            info.className = 'rank-info';
            info.innerHTML = `<strong>#${i+1}</strong><br>œÉ = ${sigma.toFixed(1)}`;
            div.appendChild(cvs); div.appendChild(info); rankGrid.appendChild(div);
        }
    }

    function reconstructImage(k) {
        reconCanvas.width = imgWidth; reconCanvas.height = imgHeight;
        let reconMat = new Array(imgHeight).fill(0).map(() => new Array(imgWidth).fill(0));
        for (let i = 0; i < k; i++) {
            const sigma = svdResult.S[i];
            const u = getColumn(svdResult.U, i);
            const v = getColumn(svdResult.V, i);
            for (let y = 0; y < imgHeight; y++) {
                const weightedU = sigma * u[y];
                for (let x = 0; x < imgWidth; x++) {
                    reconMat[y][x] += weightedU * v[x];
                }
            }
        }
        drawMatrixToCanvas(reconMat, reconCanvas);
        reconLabel.textContent = `Ïû¨Íµ¨ÏÑ± (Top ${k} Ìï©Í≥Ñ)`;
    }

    function drawSingularValuePlot(S) {
        const kIndices = S.map((_, i) => i + 1);
        const trace1 = { x: kIndices, y: S, mode: 'lines', name: 'Singular Value (œÉ)', line: { color: '#3498db', width: 3 } };
        const layout = { title: 'Singular Values Decay (Scree Plot)', xaxis: { title: 'Index k' }, yaxis: { title: 'Magnitude (œÉ)' }, margin: { t: 40, r: 20, l: 60, b: 40 }, paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: '#fafafa', hovermode: 'closest' };
        Plotly.newPlot('plot-area', [trace1], layout, {responsive: true});
        document.getElementById('plot-area').on('plotly_click', function(data){
            const pt = data.points[0];
            const idx = Math.floor(pt.x);
            if (idx > 0 && idx <= kSlider.max) { kSlider.value = idx; kValue.textContent = idx; reconstructImage(idx); }
        });
    }

    function getColumn(matrix, colIndex) {
        const len = matrix.length;
        const col = new Float32Array(len);
        for(let i=0; i<len; i++) col[i] = matrix[i][colIndex];
        return col;
    }
    function outerProduct(u, v, sigma) {
        let res = [];
        for (let i = 0; i < u.length; i++) {
            let row = new Float32Array(v.length);
            const s_u_i = u[i] * sigma;
            for (let j = 0; j < v.length; j++) row[j] = s_u_i * v[j];
            res.push(row);
        }
        return res;
    }
    function drawMatrixToCanvas(matrix, canvas) {
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(canvas.width, canvas.height);
        const data = imgData.data;
        let p = 0;
        for (let y = 0; y < canvas.height; y++) {
            const row = matrix[y];
            for (let x = 0; x < canvas.width; x++) {
                let val = row[x];
                if (val < 0) val = 0; else if (val > 255) val = 255;
                val = val | 0; 
                data[p++] = val; data[p++] = val; data[p++] = val; data[p++] = 255;
            }
        }
        ctx.putImageData(imgData, 0, 0);
    }
    function drawMatrixToCanvasNormalized(matrix, canvas) {
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(canvas.width, canvas.height);
        const data = imgData.data;
        let min = Infinity, max = -Infinity;
        for(let y=0; y<canvas.height; y++){ const row = matrix[y]; for(let x=0; x<canvas.width; x++){ const val = row[x]; if(val < min) min = val; if(val > max) max = val; }}
        const range = max - min || 1;
        let p = 0;
        for (let y = 0; y < canvas.height; y++) {
            const row = matrix[y];
            for (let x = 0; x < canvas.width; x++) {
                let norm = ((row[x] - min) / range) * 255;
                norm = norm | 0; 
                data[p++] = norm; data[p++] = norm; data[p++] = norm; data[p++] = 255;
            }
        }
        ctx.putImageData(imgData, 0, 0);
    }
    kSlider.addEventListener('input', (e) => {
        const k = parseInt(e.target.value);
        kValue.textContent = k;
        if(svdResult) reconstructImage(k);
    });
</script>
</body>
</html>
