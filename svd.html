<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVD Image Analysis (Max 256)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>

    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #f4f6f8; margin: 0; padding: 20px; color: #333; position: relative; }
        
        /* Home Button */
        .home-btn {
            position: absolute;
            top: 20px; left: 20px;
            background-color: #34495e; color: white;
            text-decoration: none; padding: 10px 15px;
            border-radius: 5px; font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: 0.3s; display: flex; align-items: center; gap: 5px; z-index: 100;
        }
        .home-btn:hover { background-color: #2c3e50; transform: translateY(-2px); }

        .container { max-width: 1000px; margin: 0 auto; background: #fff; padding: 30px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); }
        
        h1, h2 { text-align: center; color: #2c3e50; margin-bottom: 10px; }
        h2 { margin-top: 40px; border-bottom: 2px solid #eee; padding-bottom: 10px; font-size: 1.4rem; }
        
        /* Input & Status */
        .controls { text-align: center; margin: 20px 0; padding: 20px; background: #eef2f7; border-radius: 8px; border: 1px dashed #cbd5e0; }
        #status { font-weight: bold; color: #e74c3c; min-height: 20px; margin-top: 10px; white-space: pre-wrap;}

        /* Section 1: Comparison */
        .comparison-area { display: flex; justify-content: space-around; flex-wrap: wrap; gap: 20px; margin-top: 20px; }
        .image-box { text-align: center; }
        .image-box canvas { border: 1px solid #ddd; box-shadow: 2px 4px 8px rgba(0,0,0,0.1); max-width: 100%; }
        .label { display: block; margin-top: 8px; font-weight: bold; color: #555; }
        
        /* Slider */
        .slider-container { text-align: center; margin: 20px 0; display: none; background: #fff; padding: 10px; }
        input[type=range] { width: 300px; accent-color: #3498db; }
        
        /* Section 2: Rank-1 Grid */
        .rank-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin-top: 20px; }
        .rank-item { text-align: center; background: #fafafa; padding: 8px; border-radius: 5px; border: 1px solid #eee; transition: transform 0.2s; }
        .rank-item:hover { transform: scale(1.03); border-color: #3498db; }
        .rank-item canvas { width: 100%; height: auto; border: 1px solid #ddd; }
        .rank-info { font-size: 0.8rem; color: #666; margin-top: 5px; }

        /* Section 3: Plot */
        #plot-area { width: 100%; height: 400px; margin-top: 20px; }
    </style>
</head>
<body>

    <a href="https://hufsaim.github.io/T03108701/" class="home-btn">ğŸ  Home</a>

    <div class="container">
        <h1>ğŸ–¼ï¸ Image SVD Visualizer (Max 256px)</h1>
        <p style="text-align: center; color: #7f8c8d;">
            ì´ë¯¸ì§€ë¥¼ í‘ë°± í–‰ë ¬ Aë¡œ ë³€í™˜í•˜ê³  SVD ê³¼ì •ì„ ì‹œê°í™”í•©ë‹ˆë‹¤.<br>
            (ì´ë¯¸ì§€ê°€ í´ ê²½ìš° 256px ë¦¬ì‚¬ì´ì§• í›„ ê³„ì‚°í•©ë‹ˆë‹¤.)
        </p>

        <div class="controls">
            <input type="file" id="imageInput" accept="image/*">
            <div id="status"></div>
        </div>

        <h2>1. ì´ë¯¸ì§€ ì¬êµ¬ì„± (Reconstruction)</h2>
        <div class="slider-container" id="sliderArea">
            <label for="kSlider">ì‚¬ìš©í•  íŠ¹ì´ê°’ ê°œìˆ˜ (k): <span id="kValue" style="color:#2980b9; font-weight:bold; font-size: 1.2rem;">10</span></label><br>
            <input type="range" id="kSlider" min="1" max="50" value="10">
            <p style="font-size: 0.85rem; color: #888;">ìŠ¬ë¼ì´ë”ë¥¼ ì›€ì§ì—¬ kê°œì˜ ì„±ë¶„ì„ í•©ì¹œ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”.</p>
        </div>

        <div class="comparison-area">
            <div class="image-box">
                <canvas id="originalCanvas"></canvas>
                <span class="label" id="origLabel">ì›ë³¸ (Grayscale)</span>
            </div>
            <div class="image-box">
                <canvas id="reconCanvas"></canvas>
                <span class="label" id="reconLabel">ì¬êµ¬ì„± (k=10)</span>
            </div>
        </div>

        <h2>2. Top 10 Rank-1 Matrices</h2>
        <p style="text-align: center; font-size: 0.9rem; color:#7f8c8d;">
            ê°€ì¥ ì •ë³´ëŸ‰ì´ ë§ì€ ìƒìœ„ 12ê°œì˜ ì£¼ì„±ë¶„ ì‹œê°í™”
        </p>
        <div id="rankGrid" class="rank-grid"></div>

        <h2>3. Singular Value ë¶„í¬ (Scree Plot)</h2>
        <p style="text-align: center; font-size: 0.9rem; color:#7f8c8d;">
            kë²ˆì§¸ singular valueì˜ í¬ê¸° ë³€í™” ê·¸ë˜í”„ (Click point to update k)
        </p>
        <div id="plot-area"></div>
    </div>

<script>
    // Elements
    const imageInput = document.getElementById('imageInput');
    const statusDiv = document.getElementById('status');
    const originalCanvas = document.getElementById('originalCanvas');
    const reconCanvas = document.getElementById('reconCanvas');
    const rankGrid = document.getElementById('rankGrid');
    const kSlider = document.getElementById('kSlider');
    const kValue = document.getElementById('kValue');
    const sliderArea = document.getElementById('sliderArea');
    const reconLabel = document.getElementById('reconLabel');
    const origLabel = document.getElementById('origLabel');

    let svdResult = null; 
    let imgWidth = 0;
    let imgHeight = 0;

    // --- 1. Load Image ---
    imageInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        // Reset UI
        statusDiv.textContent = "â³ ì´ë¯¸ì§€ ë¡œë”© ì¤‘...";
        svdResult = null;
        sliderArea.style.display = "none";
        rankGrid.innerHTML = "";
        Plotly.purge('plot-area');

        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => processImage(img);
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });

    function processImage(img) {
        statusDiv.textContent = "â³ ì „ì²˜ë¦¬ ì¤‘... (ë¦¬ì‚¬ì´ì§•)";
        
        // --- RESIZING LOGIC (Max 256px) ---
        const maxSize = 256; 
        let width = img.width;
        let height = img.height;
        
        if (width > height) {
            if (width > maxSize) {
                height *= maxSize / width;
                width = maxSize;
            }
        } else {
            if (height > maxSize) {
                width *= maxSize / height;
                height = maxSize;
            }
        }
        width = Math.floor(width);
        height = Math.floor(height);
        
        imgWidth = width;
        imgHeight = height;
        
        // UI Update
        origLabel.textContent = `ì›ë³¸ (Gray) - ${width}x${height}`;
        reconCanvas.width = width;
        reconCanvas.height = height;

        // Draw Original
        originalCanvas.width = width;
        originalCanvas.height = height;
        const ctx = originalCanvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        // Convert to Matrix
        const imgData = ctx.getImageData(0, 0, width, height);
        const matrix = convertToGrayscaleMatrix(imgData, width, height);
        
        // Show Grayscale Version
        drawMatrixToCanvas(matrix, originalCanvas);

        // Run SVD Async (Give slight delay for UI to render text)
        statusDiv.innerHTML = `â³ SVD ê³„ì‚° ì¤‘...<br>(ì´ë¯¸ì§€ í¬ê¸° ${width}x${height}. ìˆ˜ ì´ˆê°€ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.)`;
        
        setTimeout(() => {
            requestAnimationFrame(() => performSVD(matrix));
        }, 100);
    }

    function convertToGrayscaleMatrix(imgData, w, h) {
        let matrix = [];
        for (let y = 0; y < h; y++) {
            let row = [];
            for (let x = 0; x < w; x++) {
                const idx = (y * w + x) * 4;
                const gray = 0.299 * imgData.data[idx] + 0.587 * imgData.data[idx+1] + 0.114 * imgData.data[idx+2];
                row.push(gray);
            }
            matrix.push(row);
        }
        return matrix;
    }

    // --- 2. Perform SVD ---
    function performSVD(matrix) {
        try {
            const startTime = performance.now();
            
            // numeric.svd returns {U, S, V}
            const svd = numeric.svd(matrix);
            
            const endTime = performance.now();
            const timeTaken = ((endTime - startTime) / 1000).toFixed(2);
            
            svdResult = { U: svd.U, S: svd.S, V: svd.V };

            statusDiv.innerHTML = `âœ… ì™„ë£Œ! (ì†Œìš” ì‹œê°„: ${timeTaken}ì´ˆ, Singular Values: ${svd.S.length}ê°œ)`;
            statusDiv.style.color = "#27ae60";

            sliderArea.style.display = "block";
            
            // Set Slider Range
            const maxK = svdResult.S.length;
            kSlider.max = Math.min(100, maxK); // Limit slider max to 100 for responsiveness
            kSlider.value = 10;
            kValue.textContent = 10;

            // Update UI
            visualizeRankOneMatrices(12);
            reconstructImage(12);
            drawSingularValuePlot(svdResult.S); 

        } catch (err) {
            console.error(err);
            statusDiv.innerHTML = "âŒ ê³„ì‚° ì‹¤íŒ¨.<br>ë©”ëª¨ë¦¬ ë¶€ì¡± í˜¹ì€ ë¸Œë¼ìš°ì € ì œí•œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>ë” ì‘ì€ ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.";
            statusDiv.style.color = "#c0392b";
        }
    }

    // --- 3. Visualization ---
    
    // Top N Grid
    function visualizeRankOneMatrices(n) {
        rankGrid.innerHTML = "";
        for (let i = 0; i < n; i++) {
            const sigma = svdResult.S[i];
            const u = getColumn(svdResult.U, i);
            const v = getColumn(svdResult.V, i);
            
            // Rank-1 Matrix
            const rank1Mat = outerProduct(u, v, sigma);
            
            const div = document.createElement('div');
            div.className = 'rank-item';
            const cvs = document.createElement('canvas');
            cvs.width = imgWidth;
            cvs.height = imgHeight;
            
            drawMatrixToCanvasNormalized(rank1Mat, cvs);
            
            const info = document.createElement('div');
            info.className = 'rank-info';
            info.innerHTML = `<strong>#${i+1}</strong><br>Ïƒ = ${sigma.toFixed(1)}`;
            
            div.appendChild(cvs);
            div.appendChild(info);
            rankGrid.appendChild(div);
        }
    }

    // Reconstruction
    function reconstructImage(k) {
        reconCanvas.width = imgWidth;
        reconCanvas.height = imgHeight;
        
        let reconMat = new Array(imgHeight).fill(0).map(() => new Array(imgWidth).fill(0));

        // Using loop optimization for faster reconstruction update
        for (let i = 0; i < k; i++) {
            const sigma = svdResult.S[i];
            const u = getColumn(svdResult.U, i);
            const v = getColumn(svdResult.V, i);

            for (let y = 0; y < imgHeight; y++) {
                // Optimization: Pre-calculate sigma * u[y]
                const weightedU = sigma * u[y];
                for (let x = 0; x < imgWidth; x++) {
                    reconMat[y][x] += weightedU * v[x];
                }
            }
        }
        drawMatrixToCanvas(reconMat, reconCanvas);
        reconLabel.textContent = `ì¬êµ¬ì„± (Top k í•©ê³„)`;
    }

    // --- 4. Plotly Chart ---
    function drawSingularValuePlot(S) {
        const kIndices = S.map((_, i) => i + 1);
        
        const trace1 = {
            x: kIndices, y: S,
            mode: 'lines',
            name: 'Singular Value (Ïƒ)',
            line: { color: '#3498db', width: 2 }
        };

        const layout = {
            title: 'Singular Values Decay',
            xaxis: { title: 'Index k' },
            yaxis: { title: 'Magnitude (Ïƒ)' },
            margin: { t: 40, r: 20, l: 60, b: 40 },
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: '#fafafa',
            hovermode: 'closest'
        };

        Plotly.newPlot('plot-area', [trace1], layout, {responsive: true});
        
        document.getElementById('plot-area').on('plotly_click', function(data){
            const pt = data.points[0];
            const idx = Math.floor(pt.x);
            if (idx > 0 && idx <= kSlider.max) { 
                kSlider.value = idx;
                kValue.textContent = idx;
                reconstructImage(idx);
            }
        });
    }


    // --- Helper Functions ---
    function getColumn(matrix, colIndex) {
        // Optimization: Single loop
        const len = matrix.length;
        const col = new Float32Array(len);
        for(let i=0; i<len; i++){
            col[i] = matrix[i][colIndex];
        }
        return col;
    }

    function outerProduct(u, v, sigma) {
        let res = [];
        for (let i = 0; i < u.length; i++) {
            let row = new Float32Array(v.length);
            const s_u_i = u[i] * sigma;
            for (let j = 0; j < v.length; j++) {
                row[j] = s_u_i * v[j];
            }
            res.push(row);
        }
        return res;
    }

    function drawMatrixToCanvas(matrix, canvas) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const imgData = ctx.createImageData(w, h);
        const data = imgData.data;
        
        let p = 0;
        for (let y = 0; y < h; y++) {
            const row = matrix[y];
            for (let x = 0; x < w; x++) {
                let val = row[x];
                if (val < 0) val = 0;
                else if (val > 255) val = 255;
                
                // Bitwise floor
                val = val | 0; 

                data[p++] = val; 
                data[p++] = val; 
                data[p++] = val; 
                data[p++] = 255;
            }
        }
        ctx.putImageData(imgData, 0, 0);
    }

    function drawMatrixToCanvasNormalized(matrix, canvas) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const imgData = ctx.createImageData(w, h);
        const data = imgData.data;

        let min = Infinity, max = -Infinity;
        // Find min/max
        for(let y=0; y<h; y++){
            const row = matrix[y];
            for(let x=0; x<w; x++){
                const val = row[x];
                if(val < min) min = val;
                if(val > max) max = val;
            }
        }

        const range = max - min || 1;
        
        let p = 0;
        for (let y = 0; y < h; y++) {
            const row = matrix[y];
            for (let x = 0; x < w; x++) {
                let norm = ((row[x] - min) / range) * 255;
                norm = norm | 0; // fast floor
                data[p++] = norm; 
                data[p++] = norm; 
                data[p++] = norm; 
                data[p++] = 255;
            }
        }
        ctx.putImageData(imgData, 0, 0);
    }

    // Slider Event (Throttled slightly could be better, but simple is ok here)
    kSlider.addEventListener('input', (e) => {
        const k = parseInt(e.target.value);
        kValue.textContent = k;
        if(svdResult) reconstructImage(k);
    });

</script>
</body>
</html>
