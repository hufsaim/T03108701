<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image SVD Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f2f5; margin: 0; padding: 20px; color: #333; }
        h1, h2 { text-align: center; color: #2c3e50; }
        .container { max-width: 1000px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        
        /* Input Area */
        .controls { text-align: center; margin-bottom: 20px; padding: 20px; background: #e8f4f8; border-radius: 8px; }
        input[type="file"] { padding: 10px; }
        
        /* Layout */
        .comparison-area { display: flex; justify-content: space-around; flex-wrap: wrap; gap: 20px; margin-bottom: 30px; }
        .image-box { text-align: center; }
        .image-box canvas { border: 1px solid #ccc; box-shadow: 2px 2px 5px rgba(0,0,0,0.1); max-width: 100%; }
        .label { display: block; margin-top: 5px; font-weight: bold; color: #555; }
        
        /* Rank-1 Grid */
        .rank-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 15px; margin-top: 20px; }
        .rank-item { text-align: center; background: #fafafa; padding: 10px; border-radius: 5px; border: 1px solid #eee; }
        .rank-item canvas { width: 100%; height: auto; border: 1px solid #ddd; }
        .rank-info { font-size: 0.85rem; color: #666; margin-top: 5px; }

        /* Loading */
        #status { text-align: center; font-weight: bold; color: #e74c3c; height: 20px; margin: 10px 0; }
        
        /* Slider */
        .slider-container { text-align: center; margin: 20px 0; display: none; }
        input[type=range] { width: 300px; }
    </style>
</head>
<body>

<div class="container">
    <h1>ğŸ–¼ï¸ Image SVD Analysis</h1>
    <p style="text-align: center; color: #666;">
        ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ë©´ í‘ë°± í–‰ë ¬ Aë¡œ ë³€í™˜í•˜ê³  singular value decompositionì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.<br>
        ìƒìœ„ kê°œì˜ Rank-1 í–‰ë ¬ì„ í•©ì‚°í•˜ì—¬ ì¬êµ¬ì„±ëœ ì´ë¯¸ì§€ë¥¼ í™•ì¸í•˜ê³ , ê° Rank-1 ì„±ë¶„ì„ ì‹œê°í™”í•©ë‹ˆë‹¤.
    </p>

    <div class="controls">
        <input type="file" id="imageInput" accept="image/*">
        <div id="status"></div>
    </div>

    <h2>1. ì›ë³¸ vs ì¬êµ¬ì„± ë¹„êµ</h2>
    <div class="slider-container" id="sliderArea">
        <label for="kSlider">í•©ì¹  Rank-1 í–‰ë ¬ ê°œìˆ˜ (k): <span id="kValue" style="color:#2980b9; font-weight:bold;">10</span></label><br>
        <input type="range" id="kSlider" min="1" max="50" value="10">
    </div>

    <div class="comparison-area">
        <div class="image-box">
            <canvas id="originalCanvas"></canvas>
            <span class="label">ì›ë³¸ (Grayscale)</span>
        </div>
        <div class="image-box">
            <canvas id="reconCanvas"></canvas>
            <span class="label" id="reconLabel">ì¬êµ¬ì„± (Top 10 í•©ê³„)</span>
        </div>
    </div>

    <h2>2. Top 10 Rank-1 Matrices</h2>
    <p style="text-align: center; font-size: 0.9rem; color:#7f8c8d;">
        * ê° ì´ë¯¸ì§€ëŠ” í•´ë‹¹ ì„±ë¶„ì´ ë‹´ê³  ìˆëŠ” ì •ë³´(íŒ¨í„´)ë¥¼ ì‹œê°í™”í•œ ê²ƒì…ë‹ˆë‹¤. (ì •ê·œí™”ë¨)
    </p>
    <div id="rankGrid" class="rank-grid">
        </div>
</div>

<script>
    const imageInput = document.getElementById('imageInput');
    const statusDiv = document.getElementById('status');
    const originalCanvas = document.getElementById('originalCanvas');
    const reconCanvas = document.getElementById('reconCanvas');
    const rankGrid = document.getElementById('rankGrid');
    const kSlider = document.getElementById('kSlider');
    const kValue = document.getElementById('kValue');
    const sliderArea = document.getElementById('sliderArea');
    const reconLabel = document.getElementById('reconLabel');

    let svdResult = null; // Store {U, S, V}
    let imgWidth = 0;
    let imgHeight = 0;

    // --- 1. Image Loading & Processing ---
    imageInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => processImage(img);
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });

    function processImage(img) {
        statusDiv.textContent = "â³ ì²˜ë¦¬ ì¤‘... (ì´ë¯¸ì§€ ë¦¬ì‚¬ì´ì§• ë° SVD ê³„ì‚°)";
        
        // 1. Resize logic (SVD is O(n^3), keep it small for browser)
        const maxSize = 320; 
        let width = img.width;
        let height = img.height;
        
        if (width > height) {
            if (width > maxSize) { height *= maxSize / width; width = maxSize; }
        } else {
            if (height > maxSize) { width *= maxSize / height; height = maxSize; }
        }
        width = Math.floor(width);
        height = Math.floor(height);
        
        imgWidth = width;
        imgHeight = height;

        // 2. Draw Original & Get Matrix
        originalCanvas.width = width;
        originalCanvas.height = height;
        const ctx = originalCanvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        const imgData = ctx.getImageData(0, 0, width, height);
        const matrix = convertToGrayscaleMatrix(imgData, width, height);
        
        // Redraw Grayscale to original canvas
        drawMatrixToCanvas(matrix, originalCanvas);

        // 3. Perform SVD (Async to allow UI update)
        setTimeout(() => {
            performSVD(matrix);
        }, 100);
    }

    // Convert RGB ImageData to 2D Array (0-255)
    function convertToGrayscaleMatrix(imgData, w, h) {
        let matrix = [];
        for (let y = 0; y < h; y++) {
            let row = [];
            for (let x = 0; x < w; x++) {
                const idx = (y * w + x) * 4;
                // Standard Grayscale: 0.299R + 0.587G + 0.114B
                const gray = 0.299 * imgData.data[idx] + 0.587 * imgData.data[idx+1] + 0.114 * imgData.data[idx+2];
                row.push(gray);
            }
            matrix.push(row);
        }
        return matrix;
    }

    // --- 2. SVD Computation ---
    function performSVD(matrix) {
        try {
            // numeric.svd returns U, S (vector), V
            // A = U . diag(S) . V^T
            // numeric.js V is usually returned as V, so we need transpose for reconstruction formula A = U S V'
            const svd = numeric.svd(matrix);
            
            svdResult = {
                U: svd.U,
                S: svd.S,
                V: svd.V // In numeric.js, this is V.
            };

            statusDiv.textContent = "";
            sliderArea.style.display = "block";
            kSlider.max = Math.min(50, svdResult.S.length);
            kSlider.value = 10;
            kValue.textContent = 10;

            // Visualize
            visualizeRankOneMatrices(10);
            reconstructImage(10);

        } catch (err) {
            console.error(err);
            statusDiv.textContent = "âŒ SVD ê³„ì‚° ì¤‘ ì˜¤ë¥˜ ë°œìƒ.";
        }
    }

    // --- 3. Visualization Logic ---
    
    // Visualize Top N Rank-1 matrices
    function visualizeRankOneMatrices(n) {
        rankGrid.innerHTML = ""; // Clear
        
        for (let i = 0; i < n; i++) {
            // Calculate Rank-1 Matrix: sigma_i * u_i * v_i^T
            // u_i is i-th column of U
            // v_i is i-th column of V (since we have V, not V^T yet)
            
            const sigma = svdResult.S[i];
            const u_vec = getColumn(svdResult.U, i);
            const v_vec = getColumn(svdResult.V, i);
            
            // Outer Product
            const rank1Mat = outerProduct(u_vec, v_vec, sigma);
            
            // Create Canvas Element
            const div = document.createElement('div');
            div.className = 'rank-item';
            const cvs = document.createElement('canvas');
            cvs.width = imgWidth;
            cvs.height = imgHeight;
            
            // Draw Normalized (because rank-1 components have negative values)
            drawMatrixToCanvasNormalized(rank1Mat, cvs);
            
            const info = document.createElement('div');
            info.className = 'rank-info';
            info.innerHTML = `<strong>Rank-${i+1}</strong><br>Ïƒ = ${sigma.toFixed(1)}`;
            
            div.appendChild(cvs);
            div.appendChild(info);
            rankGrid.appendChild(div);
        }
    }

    // Reconstruct Image using Top K singular values
    function reconstructImage(k) {
        reconCanvas.width = imgWidth;
        reconCanvas.height = imgHeight;
        
        // Start with zero matrix
        let reconMat = new Array(imgHeight).fill(0).map(() => new Array(imgWidth).fill(0));

        // Sum top k matrices
        for (let i = 0; i < k; i++) {
            const sigma = svdResult.S[i];
            const u_vec = getColumn(svdResult.U, i);
            const v_vec = getColumn(svdResult.V, i);

            for (let y = 0; y < imgHeight; y++) {
                for (let x = 0; x < imgWidth; x++) {
                    reconMat[y][x] += sigma * u_vec[y] * v_vec[x];
                }
            }
        }

        drawMatrixToCanvas(reconMat, reconCanvas); // Standard drawing (clamped 0-255)
        reconLabel.textContent = `ì¬êµ¬ì„± (Top ${k} í•©ê³„)`;
    }

    // --- Helper Math Functions ---

    function getColumn(matrix, colIndex) {
        return matrix.map(row => row[colIndex]);
    }

    function outerProduct(u, v, sigma) {
        let res = [];
        for (let i = 0; i < u.length; i++) {
            let row = [];
            for (let j = 0; j < v.length; j++) {
                row.push(u[i] * v[j] * sigma);
            }
            res.push(row);
        }
        return res;
    }

    // Draw Matrix directly (Clamping 0-255) - used for reconstruction & original
    function drawMatrixToCanvas(matrix, canvas) {
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(canvas.width, canvas.height);
        
        let p = 0;
        for (let y = 0; y < matrix.length; y++) {
            for (let x = 0; x < matrix[y].length; x++) {
                let val = matrix[y][x];
                // Clamp
                if (val < 0) val = 0;
                if (val > 255) val = 255;
                val = Math.floor(val);

                imgData.data[p++] = val; // R
                imgData.data[p++] = val; // G
                imgData.data[p++] = val; // B
                imgData.data[p++] = 255; // Alpha
            }
        }
        ctx.putImageData(imgData, 0, 0);
    }

    // Draw Matrix Normalized (Scaling min-max to 0-255) - used for abstract Rank-1 components
    function drawMatrixToCanvasNormalized(matrix, canvas) {
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(canvas.width, canvas.height);
        
        // Find min/max
        let min = Infinity, max = -Infinity;
        for (let y = 0; y < matrix.length; y++) {
            for (let x = 0; x < matrix[y].length; x++) {
                const val = matrix[y][x];
                if (val < min) min = val;
                if (val > max) max = val;
            }
        }
        
        const range = max - min;

        let p = 0;
        for (let y = 0; y < matrix.length; y++) {
            for (let x = 0; x < matrix[y].length; x++) {
                let val = matrix[y][x];
                // Normalize to 0-255
                let norm = ((val - min) / (range || 1)) * 255;
                norm = Math.floor(norm);

                imgData.data[p++] = norm;
                imgData.data[p++] = norm;
                imgData.data[p++] = norm;
                imgData.data[p++] = 255;
            }
        }
        ctx.putImageData(imgData, 0, 0);
    }

    // UI: Slider Change Event
    kSlider.addEventListener('input', (e) => {
        const k = parseInt(e.target.value);
        kValue.textContent = k;
        if(svdResult) reconstructImage(k);
    });

</script>

</body>
</html>